### 实验记录

| 实验编号 | 实现方式                        | 设备/模拟器 | 矩阵尺寸 (M×K×N) | 计算耗时 (ms) | 备注 |
| -------: | ------------------------------- | ----------- | ---------------: | ------------: | ---: |
|        1 | 朴素 baseline-transB            | QDC 8 Elite |         64×64×64 |        49.397 |      |
|        2 | baseline                        | QDC 8 Elite |         64×64×64 |        39.742 |      |
|        3 | HVX 内积 (A * B^T)              | QDC 8 Elite |         64×64×64 |        41.319 |      |
|        4 | HVX 外积 (A * B)                | QDC 8 Elite |         64×64×64 |        30.557 |      |
|        5 | HVX 内积 带l2fetch              | QDC 8 Elite |         64×64×64 |        41.306 |      |
|        6 | HVX 外积 带l2fetch              | QDC 8 Elite |         64×64×64 |        30.869 |      |
|        7 | 朴素 baseline-transB            | QDC 8 Elite |      256×256×256 |       428.714 |      |
|        8 | baseline                        | QDC 8 Elite |      256×256×256 |       543.022 |      |
|        9 | HVX 内积 (A * B^T)              | QDC 8 Elite |      256×256×256 |       125.015 |      |
|       10 | HVX 外积 (A * B)                | QDC 8 Elite |      256×256×256 |        77.617 |      |
|       11 | HVX 内积 带l2fetch              | QDC 8 Elite |      256×256×256 |       131.343 |      |
|       12 | HVX 外积 带l2fetch              | QDC 8 Elite |      256×256×256 |        80.452 |      |
|       13 | 朴素 baseline-transB            | QDC 8 Elite |      512×512×512 |      2997.152 |      |
|       14 | baseline                        | QDC 8 Elite |      512×512×512 |      5321.020 |      |
|       15 | HVX 内积 (A * B^T)              | QDC 8 Elite |      512×512×512 |       488.566 |      |
|       16 | HVX 外积 (A * B)                | QDC 8 Elite |      512×512×512 |       352.797 |      |
|       17 | HVX 内积 带l2fetch              | QDC 8 Elite |      512×512×512 |       421.085 |      |
|       18 | HVX 外积 带l2fetch              | QDC 8 Elite |      512×512×512 |       323.304 |      |
|       19 | 朴素 baseline-transB            | QDC 8 Elite |         88×99×66 |        57.779 |      |
|       20 | baseline                        | QDC 8 Elite |         88×99×66 |        56.065 |      |
|       21 | HVX 内积 (A * B^T)              | QDC 8 Elite |         88×99×66 |        43.362 |      |
|       22 | HVX 外积 (A * B)                | QDC 8 Elite |         88×99×66 |        33.859 |      |
|       23 | HVX 内积 带l2fetch              | QDC 8 Elite |         88×99×66 |        42.546 |      |
|       24 | HVX 外积 带l2fetch              | QDC 8 Elite |         88×99×66 |        34.107 |      |
|     Add1 | HVX 内积 带l2fetch 带enroll求和 | QDC 8 Elite |      256×256×256 |       126.380 |      |
|     Add2 | HVX 外积 带l2fetch              | QDC 8 Elite |      256×256×256 |        81.776 |      |
|     Add3 | HVX 内积 带l2fetch 带enroll求和 | QDC 8 Elite |   1024x1024x1024 |      2571.810 |      |
|     Add4 | HVX 外积 带l2fetch              | QDC 8 Elite |   1024x1024x1024 |      3050.668 |      |
|     Add5 | HVX 内积 带l2fetch 带enroll求和 | QDC 8 Elite |   2048x2048x2048 |     18048.596 |      |
|     Add6 | HVX 外积 带l2fetch              | QDC 8 Elite |   2048x2048x2048 |     31720.266 |      |
|          |                                 |             |                  |               |      |

~~折磨AI折磨自己调了半天的代码总得给他找个地方能跑得快点.jpg~~

代码见同目录下calculator_imp.c.

### 数据分析

我实现了用hvx的版本，和带l2fetch预读的版本。

在矩阵比较小的时候，hvx能有一定加速能力，但是l2fetch加速不明显，并且此时转置矩阵显然花费了不少时间求和，导致转置的baseline性能不如不转置。

在数据更大的时候，转置在朴素算法中提供了很高的提升：这样内存局部性更好，可以大幅度减少cache miss次数，所以在512×512×512的时候，甚至取得了接近一倍的提升。

hvx在更大规模的数据上，有无与伦比的优势。hvx能并行处理数据，大幅度减少计算开销。

l2fetch使用预读，在矩阵很大的时候，可以提高大概20%的性能。

在小矩阵时，外积法几乎完全有性能优势。只有在非常大的矩阵时，内积法能获得更大的提升。

### 性能分析

#### 场景 1：中小型矩阵 (N <= 512)

- **测试数据：** 64x64x64, 256x256x256, 512x512x512, 88x99x66
- **性能瓶颈分析：**
  - **内积法 (`A * B^T`)**：其**主要瓶颈是“水平求和” (Horizontal Sum) 的计算开销**。为了得到 1 个 `C[i,j]`，它必须执行一次昂贵的水平求和 (1 次 HVX 存储 + 32 次标量加载和累加)。在 `N=512` 时，这意味着 `512*512 = 262,144` 次水平求和，这个计算开销远大于内存访问的开销。在cuda里面，可以用wrap shuffle(__shf1)指令直接光速给它合了，~~当然在cuda上有更好用的cuBLAS，也用不着写这么多~~
  - **外积法 (`A * B`)**：其**理论瓶颈是“大步长 (Stride-N) 内存访问”**。然而，在 `N <= 512` 时，性能似乎不符合预期。推测为，高通做了硬件预取，极好地 隐藏了这个延迟。`N=512` (步长 2KB) 似乎是硬件预取的极限。由于它完全没有水平求和，其计算效率最高，因此胜出。

#### 场景 2：大型矩阵 (N >= 1024)

- **测试数据：** 1024x1024x1024, 2048x2048x2048
- **性能瓶颈分析：**
  - **外积法 **：**瓶颈转变为内存**。`N=1024` (步长 4KB) 或 `N=2048` (步长 8KB) 的内存步长远远超过缓存能覆盖的范围，让缓存和硬件预取器基本失效。CPU 绝大部分时间都在等待 `B` 矩阵的数据从主存 中获取，导致性能严重下降。
  - **内积法**：**瓶颈回到了计算**。
    1. 通过循环分块将其计算瓶颈（水平求和）的开销**分摊减半**。
    2. 线性内存访问在此时成为了决定性因素。它不会撞上“内存墙”，数据可以高效地从内存流式传输到 HVX。
    3. 因此，它的性能（18048 ms）能够随着问题规模（`M*N*K`）**近乎线性地增长**，而外积法已经因为内存瓶颈而失败。

### 关键HVX指令

```c
Q6_V_vsplat_R(bits)
```

- **详解：** 标量广播。将一个 32-bit 标量 (`bits`) 复制到 HVX 向量的所有 32 个 "lane" 中。
- **在实现中：** 外积法中，将 `A[i, l]` 广播，用于和向量 `B[l, j...]` 进行向量-标量乘法。

```C
Q6_Vqf32_vmpy_VsfVsf(Vsf1, Vsf2)
```

- **详解：** 向量浮点乘法。并行执行 32 次 `float` 乘法。
- **在实现中：** 两种方法都用它来执行核心的乘法。

```C
Q6_Vqf32_vadd_Vqf32Vqf32(Vqf1, Vqf2)
```

- **详解：** 向量浮点加法。并行执行 32 次 `float` 加法。
- **在实现中：** 两种方法都用它来将乘积 (`v_prod`) 累加到累加器 (`acc`) 上。

```C
Q6_l2fetch_AR(addr, params)
```

- **详解：** L2 缓存异步预取。指示内存控制器开始将 `addr` 处（由 `params` 定义的 1D 或 2D 区域）的数据拉入 L2 缓存。

### 优化建议

针对水平求和，用循环分块是合理的策略。以后可以用**`Q6_V_vror_VR()`** 来进一步加速，~~这玩意我没用明白~~

在数据规模很大的时候，外积法不是很适用。

针对对齐，最好是在分配时候填充一下，对齐之后再送进hvx，这样能快一些。

针对尾部，我是直接用了朴素的循环来处理。在数据规模比较大的时候，这些循环的性能影响应该不大。

### l2fetch

Q6_l2fetch_AR()让CPU将数据先读到L2，这在cache还没满但是矩阵已经很大的时候挺有用的。这条指令是一个非阻塞（non-blocking）指令；在预取操作在后台进行的同时，程序会继续执行下一条指令 。硬件仅在请求的数据行（lines）不在 L2 缓存中时，才会尝试从系统内存中获取它们 。
