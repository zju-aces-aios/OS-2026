## 任务目标

要求在 `Lab4/dsp/calculator_imp.c` 中实现并比较多种矩阵乘法实现：

- 朴素标量实现（baseline）：直接三重循环实现的 C 语言矩阵乘法，用作基线性能对比；
- 基于 HVX 的内积实现（A * B^T）：对 B 做转置，使得点积（dot-product）可以用向量化内积（内积法）计算；
- 基于 HVX 的外积实现（A * B）：采用外积法，利用标量广播将 A 的单个元素与 B 的一整段向量相乘并累加到 C 的子向量。

实现要求与验收准则：

1. 功能等价：对任意合法输入（浮点矩阵）都应输出误差在浮点容差内的结果；
2. 向量化与对齐：HVX 代码应处理 128 字节（32 float）对齐，说明如何处理尾部不对齐或非 32 倍长度的情形；
3. 性能测量：对不同矩阵尺寸执行并记录；
4. 结果分析：比较三种实现的运行时间与计算效率，并说明在实现中使用到的主要 HVX 指令与它们的作用（例如 vsplat、vmpy、vadd、vror 等）。

实验数据记录表：

- 无论是实体设备还是使用模拟器，启动参数的最后三位分别是矩阵尺寸的M、K、N

| 实验编号 | 实现方式 | 设备/模拟器 | 矩阵尺寸 (M×K×N) | 计算耗时 (ms) | 备注 |
|---:|---|---|---:|---:|---:|
| 1 | 朴素 baseline | 设备 | 64×64×64 | 53 52  | 内积 外积 |
| 2 | HVX 内积 (A * B^T) | 设备 | 64×64×64 | 43  |  |
| 3 | HVX 外积 (A * B) | 设备 | 64×64×64 |  36 |  |
| 4 | 朴素 baseline |设备  | 256×256×256 |  471 609 | 内积 外积 |
| 5 | HVX 内积 (A * B^T) | 设备 | 256×256×256 | 471  |  |
| 6 | HVX 外积 (A * B) | 设备 | 256×256×256 |  609 |  |
| 7 | 朴素 baseline | 设备 | 512×512×512 | 3597 6251  |内积 外积  |
| 8 | HVX 内积 (A * B^T) | 设备 | 512×512×512 | 915  |  |
| 9 | HVX 外积 (A * B) | 设备 | 512×512×512 | 1298  |  |
| 10 | 朴素 baseline | 设备 | 88×99×66 | 56 56  |内积 外积  |
| 11 | HVX 内积 (A * B^T) |设备 | 88×99×66 | 41  |  |
| 12 | HVX 外积 (A * B) |设备  | 88×99×66 |  41 |  |

分析要点：

1. 对比内积与外积在数据复用、内存访问模式与向量指令使用上的差异；
- 外积：A的每个元素在k循环中复用k次，B不存在复用的情况；C B都是按行访问或写入，A按照标量读取；需要用到广播、向量乘、向量加
- 内积：A的第i行全部元素在j循环中复用j次，B不存在复用的情况；A B都是按行访问，C按照标量写入；需要用到向量乘、向量加、向量规约
2. 关键 HVX 指令详解：指出在代码中使用到的每种 HVX 指令（例如 Q6_V_vsplat_R、Q6_Vqf32_vmpy_VsfVsf、Q6_Vqf32_vadd_Vqf32Vqf32、Q6_V_vror_VR 等）并解释它们在你的实现中如何改善性能；
- 外积：使用Q6_V_vsplat_R进行广播，将A中提取的标量转化为向量；使用Q6_Vqf32_vmpy_VsfVsf，将该向量与B中每行向量相乘；使用Q6_Vsf_equals_Vqf32转换向量格式后，再用Q6_Vsf_vadd_VsfVsf向量加到C中存储的结果上去。按照最标准的外积实现方法，减少指令、增加单个指令处理元素数量。
- 内积：使用Q6_Vqf32_vmpy_VsfVsf与Q6_Vsf_vadd_VsfVsf做向量内积，使用Q6_V_vror_VR与Q6_Vsf_vadd_VsfVsf做向量规约，从而快速求和提取标量。
3. 针对尾部、对齐、缓存与内存带宽瓶颈提出优化建议。
- 本次代码中，尾部元素的处理方式是转为传统标量算法。可以考虑对矩阵进行填充至32的倍数长度，未测试。


