# Lab4: Hexagon NPU GEMM

## 任务目标

要求在 `Lab4/dsp/calculator_imp.c` 中实现并比较多种矩阵乘法实现：

- 朴素标量实现（baseline）：直接三重循环实现的 C 语言矩阵乘法，用作基线性能对比；
- 基于 HVX 的内积实现（A * B^T）：对 B 做转置，使得点积（dot-product）可以用向量化内积（内积法）计算；
- 基于 HVX 的外积实现（A * B）：采用外积法，利用标量广播将 A 的单个元素与 B 的一整段向量相乘并累加到 C 的子向量。

实现要求与验收准则：

1. 功能等价：对任意合法输入（浮点矩阵）都应输出误差在浮点容差内的结果；
2. 向量化与对齐：HVX 代码应处理 128 字节（32 float）对齐，说明如何处理尾部不对齐或非 32 倍长度的情形；
3. 性能测量：对不同矩阵尺寸执行并记录；
4. 结果分析：比较三种实现的运行时间与计算效率，并说明在实现中使用到的主要 HVX 指令与它们的作用（例如 vsplat、vmpy、vadd、vror 等）。

实验数据记录表：

- 无论是实体设备还是使用模拟器，启动参数的最后三位分别是矩阵尺寸的M、K、N

| 实验编号 | 实现方式 | 设备/模拟器 | 矩阵尺寸 (M×K×N) | 计算耗时 (ms) | 备注 |
|---:|---|---|---:|---:|---:|
| 1 | 朴素 baseline |  | 64×64×64 |   |  |
| 2 | HVX 内积 (A * B^T) |  | 64×64×64 |   |  |
| 3 | HVX 外积 (A * B) |  | 64×64×64 |   |  |
| 4 | 朴素 baseline |  | 256×256×256 |   |  |
| 5 | HVX 内积 (A * B^T) |  | 256×256×256 |   |  |
| 6 | HVX 外积 (A * B) |  | 256×256×256 |   |  |
| 7 | 朴素 baseline |  | 512×512×512 |   |  |
| 8 | HVX 内积 (A * B^T) |  | 512×512×512 |   |  |
| 9 | HVX 外积 (A * B) |  | 512×512×512 |   |  |
| 10 | 朴素 baseline |  | 88×99×66 |   |  |
| 11 | HVX 内积 (A * B^T) |  | 88×99×66 |   |  |
| 12 | HVX 外积 (A * B) |  | 88×99×66 |   |  |

分析要点：

1. 对比内积与外积在数据复用、内存访问模式与向量指令使用上的差异；
2. 关键 HVX 指令详解：指出在代码中使用到的每种 HVX 指令（例如 Q6_V_vsplat_R、Q6_Vqf32_vmpy_VsfVsf、Q6_Vqf32_vadd_Vqf32Vqf32、Q6_V_vror_VR 等）并解释它们在你的实现中如何改善性能；
3. 针对尾部、对齐、缓存与内存带宽瓶颈提出优化建议。

延伸讨论（可选）：

- 翻阅硬件手册，查看l2fetch函数的作用，并尝试用在代码实现中，观察变化
- 如果采用了其他的优化手段，请在提交文档中标明

## 提交内容

- 修改后的`calculator_imp.c`
- 实验报告