实验数据记录表：

- 无论是实体设备还是使用模拟器，启动参数的最后三位分别是矩阵尺寸的M、K、N

| 实验编号 | 实现方式 | 设备/模拟器 | 矩阵尺寸 (M×K×N) | 计算耗时 (ms) | 备注 |
|---:|---|---|---:|---:|---:|
| 1 | 朴素 baseline | QDC 8 Elite  | 64×64×64 | 51.315  | \ |
| 2 | HVX 内积 (A * B^T) | QDC 8 Elite  | 64×64×64 | 44.794  | \ |
| 3 | HVX 外积 (A * B) | QDC 8 Elite  | 64×64×64 | 35.484 | \ |
| 4 | 朴素 baseline | QDC 8 Elite  | 256×256×256 | 427.711  | \ |
| 5 | HVX 内积 (A * B^T) | QDC 8 Elite  | 256×256×256 | 188.769  |\  |
| 6 | HVX 外积 (A * B) | QDC 8 Elite  | 256×256×256 | 148.200  | \ |
| 7 | 朴素 baseline | QDC 8 Elite  | 512×512×512 | 2996.846  |\  |
| 8 | HVX 内积 (A * B^T) | QDC 8 Elite  | 512×512×512 | 935.010  | \ |
| 9 | HVX 外积 (A * B) | QDC 8 Elite  | 512×512×512 | 697.481  | \ |
| 10 | 朴素 baseline | QDC 8 Elite  | 88×99×66 | 54.813  | \ |
| 11 | HVX 内积 (A * B^T) | QDC 8 Elite  | 88×99×66 | 50.510  | \ |
| 12 | HVX 外积 (A * B) | QDC 8 Elite  | 88×99×66 |  39.475 | \ |

分析要点：

1.对比内积与外积在数据复用、内存访问模式与向量指令使用上的差异

内积路径每次锁定 A 的第 i 行与转置后 B 的第 j 行，只为单个 C[i,j] 做一次长度为 K 的向量内积；向量乘加按 32 个元素一批推进，多出来的尾部再补一次零扩展，因此数据复用集中在“同一行的对位元素”，缓存命中依赖短期访问。
外积路径先把一整行 C 清零，随后遍历 K：把 A[i,l] 广播成向量，对 B 第 l 行的每个 32 元素块做乘加，累积在对应的 C 块，直到写回整行；这样同一段 B 和 C 会在循环中被重复访问，流式写入让缓存和带宽利用更高效。

2.关键 HVX 指令详解：指出在代码中使用到的每种 HVX 指令（例如 Q6_V_vsplat_R、Q6_Vqf32_vmpy_VsfVsf、Q6_Vqf32_vadd_Vqf32Vqf32、Q6_V_vror_VR 等）并解释它们在你的实现中如何改善性能

Q6_V_vsplat_R：将 A 的标量（例如 A[i,l]）复制成 32 路浮点向量，外积阶段只需一次广播即可对整段 B 做乘法。
Q6_Vqf32_vmpy_VsfVsf：执行 128B 宽的浮点乘法，内积与外积分支都用它把 32 对操作数组成乘积。
Q6_Vqf32_vadd_Vqf32Vqf32：将乘积向量累加到当前累加器，保持加法在向量单元中完成，避免回退标量循环。
Q6_V_vzero：一次性把累加寄存器清零，用在外积初始化每段 C、内积分支的尾部处理。
Q6_V_vror_VR + Q6_Vqf32_vadd_Vqf32Vqf32：在 hvx_reduce_sum 中做树形右移 + 累加，将 32 元素的向量规约到单个浮点结果，供内积分支写回。
Q6_Vsf_equals_Vqf32：把 HVX 内部的 32 位累加结果转换为常规浮点数组，方便外积分支把整段结果写回 C。

3.针对尾部、对齐、缓存与内存带宽瓶颈提出优化建议

尾部处理：当前不足 32 个元素仍靠 memcpy 搬入零向量，可改用带掩码的加载/写回指令（如 Q6_V_vmux_QVV 或 Q6_V_vldu_A），或者在主机侧把矩阵维度填充到 32 的倍数，避免频繁的额外拷贝。
对齐策略：必须保证 A/B/C 的首地址 128B 对齐，并在需要时让 B 预先转置成 32 的倍数列块，确保所有向量装存都走快路径。
缓存与带宽：大矩阵建议对 B 做块划分并搬到 VTCM，使外积循环复用同一块数据；配合主机侧或 DSP 侧的预取（例如 Q6_P_prefetch）、双缓冲加载，让计算与数据搬运重叠，进一步降低 DRAM 往返造成的性能瓶颈。

