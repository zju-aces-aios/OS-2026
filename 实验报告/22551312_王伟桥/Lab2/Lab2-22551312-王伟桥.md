# 操作系统实验二报告

**姓名：王伟桥**  
**学号：22551312**  
**实验名称：Lab2 代码纠错与内存释放修复**

---

## 一、实验目的

在完成上一个实验的基础上，本次实验旨在理解和修复 `Unikraft` 内核中的 **Buddy 内存分配器释放函数** `bbuddy_pfree()` 的实现错误，  
通过 GDB 调试验证修正效果，并加深对内存释放与空闲块合并机制的理解。

---

## 二、实验环境

- **系统环境**：Ubuntu 22.04  
- **平台工具**：
  - QEMU（ARM64 虚拟机仿真）
  - GDB-Multiarch（远程调试）
  - Unikraft 运行时框架  
- **项目地址**：[https://github.com/zju-aces-aios/OS-2026](https://github.com/zju-aces-aios/OS-2026)

---

## 三、实验内容与过程

### （1）代码修改位置

本实验主要修改文件：
```
app-helloworld/workdir/unikraft/lib/ukallocbbuddy/bbuddy.c
```

修改目标函数：
```c
static void bbuddy_pfree(struct uk_alloc *a, void *obj, unsigned long num_pages)
```

### （2）错误分析

在原始代码中，`b->free_head[0]` 可能为 `NULL`，  
而程序在未进行判空检查的情况下直接执行了：
```c
b->free_head[0]->pprev = &freed_ch->next;
```
这会导致 **空指针解引用**，程序崩溃。

此外，释放页时 `obj` 的地址未正确向后偏移，  
造成了 **页面计算错误**，多次释放同一内存块。

---

### （3）修正方案

1. 添加判空检查，避免空指针访问；
2. 在循环中对 `obj` 进行页偏移；
3. 调整释放逻辑，使每一页都能被正确挂入空闲链表。

修改后关键代码如下（节选）：

```c
int nr_page_left = 1UL << order;
while (nr_page_left) {
    freed_ch = (chunk_head_t *)obj;
    freed_ct = (chunk_tail_t *)((char *)obj + (1UL << __PAGE_SHIFT)) - 1;

    freed_ch->level = 0;
    freed_ch->next = b->free_head[0];
    freed_ch->pprev = &b->free_head[0];
    freed_ct->level = 0;

    if (freed_ch->next)
        freed_ch->next->pprev = &freed_ch->next;
    b->free_head[0] = freed_ch;

    nr_page_left--;
    obj = (char *)obj + (1UL << __PAGE_SHIFT);
}
```

---

### （4）编译与调试步骤

1. **重新编译项目**

   ```bash
   cd ~/OS-2026/app-helloworld
   make clean
   make -j8
   ```

2. **启动 QEMU 并开启 GDB 调试端口**

   ```bash
   qemu-system-aarch64        -kernel workdir/build/helloworld_qemu-arm64        -nographic -machine virt -cpu cortex-a57 -s -S
   ```

3. **连接 GDB**

   ```bash
   gdb-multiarch workdir/build/helloworld_qemu-arm64.dbg        --eval-command="target remote :1234"
   ```

4. **设置断点并调试**

   ```gdb
   (gdb) b bbuddy_pfree
   (gdb) c
   (gdb) info locals
   (gdb) p/x obj
   (gdb) p/x freed_ct
   (gdb) p num_pages
   ```

---

### （5）调试结果

- 当程序运行到断点时：
  ```gdb
  (gdb) p freed_ct
  $4 = (chunk_tail_t *) 0x44104ffc
  (gdb) p obj
  $5 = (void *) 0x44104ffd
  ```
- 修改后程序不再出现崩溃；
- 页释放地址正确偏移；
- 内存空闲链表恢复正常。

---

## 四、实验总结

通过本次实验，我学会了：
- 使用 **GDB** 对内核级内存分配代码进行单步调试；
- 理解 **Buddy System** 的页分配与释放机制；
- 掌握 **指针安全性** 与 **页偏移计算** 的重要性。

该实验帮助我进一步熟悉了 OS 内核中内存管理模块的实现细节，也提升了在 QEMU 环境下的调试能力。

---

**实验完成日期：2025 年 11 月 3 日**
