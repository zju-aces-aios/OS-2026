

### **\.Hexagon SDK 安装**

1. **手动下载** (使用 wget 下载 Hexagon\_SDK.zip)  
2. **创建文件夹后解压**  
   ```  
   unzip Hexagon\_SDK.zip \-d /home/qomolangma/Qualcomm

3. **统一的环境变量**  
   ```
   export HEXAGON\_SDK\_PATH=/home/qomolangma/Qualcomm/Hexagon\_SDK/6.3.0.0

4. **使配置生效**  
   
   ```  
   source \~/.bashrc

![image-20251103151846139](C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20251103151846139.png)

### **3\. Android NDK 安装**

1. **下载并配置 Android SDK Command Line Tools**  
   * 下载 Command Line Tools (使用 wget 下载 commandlinetools-linux-13114758\_latest.zip)  
   * 解压并组织目录结构:  
     ```
     unzip commandlinetools-linux-13114758\_latest.zip  
     mkdir \-p /Android/Sdk/cmdline-tools/latest  
     mv cmdline-tools/\* \~/Android/Sdk/cmdline-tools/latest/

   * 配置环境变量 (在 \~/.bashrc 中添加):  
     ```
     export PATH=\~/Android/Sdk/cmdline-tools/latest/bin/:$PATH

   * 使配置生效:  
     ```
     source \~/.bashrc

2. **安装 OpenJDK 17**  

   * 安装 JDK:  
     ```
     sudo apt update  
     sudo apt install openjdk-17-jdk

   * 找到 JDK 安装路径 (通常是 /usr/lib/jvm/java-17-openjdk-amd64):  
     ``` 
     sudo update-alternatives \--config java

   * 编辑环境变量文件 (/etc/environment) 并添加或修改: 
     
     ``` 
     JAVA\_HOME="/usr/lib/jvm/java-17-openjdk-amd64"
     
   * 重新加载环境变量:  
     ``` 
     source /etc/environment

   * 验证:  
     
     ``` 
     echo $JAVA\_HOME  
     java \-version

   ![image-20251103152001803](C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20251103152001803.png)

   

3. **设置 Android SDK Root**  

   * 创建 SDK 目录:  
     ``` 
     mkdir \-p /Android/Sdk

   * 设置 ANDROID\_SDK\_ROOT 环境变量 (在 \~/.bashrc 中添加):  
     ``` 
     export ANDROID\_HOME=$HOME/Android/Sdk  
     export ANDROID\_SDK\_ROOT=$HOME/Android/Sdk

   * 让环境变量生效:  
     ``` 
     source \~/.bashrc

4. **安装 NDK**  
   * 查看可用版本并安装 (报告中安装了 ndk;29.0.13113456-beta1):  
     ``` 
     sdkmanager "ndk;29.0.13113456-beta1"

   * 配置 NDK 环境变量 (在 \~/.bashrc 中添加):  
     ``` 
     export ANDROID\_NDK\_ROOT=\~/Android/Sdk/ndk/29.0.13113456-beta1/

5. **安装 ADB 工具**  
   ``` 
   sudo apt install android-tools-adb

## **代码编译与运行**

### **1\. 编译 NPU (DSP) 代码**

确保处于 /os-2026/Lab4 目录。

1. **设置 Hexagon SDK 环境并编译 DSP 代码**:  
   ``` 
   source $HEXAGON\_SDK\_PATH/setup\_sdk\_env.source  
   cd dsp

2. **安装依赖**:  
   ``` 
   sudo apt install libtinfo5

3. **编译**:  
   ``` 
   make hexagon BUILD=Debug DSP\_ARCH=v79
   ```
   
   *编译输出确认了 Hexagon Tools 版本和输出目录*.
   
   ![image-20251103152042440](C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20251103152042440.png)

### **2\. 模拟器运行**

确保处于 /os-2026/Lab4/dsp 目录且 NPU 代码编译成功.

1. **修改必要的依赖库**:  
   ``` 
   sudo ln \-s /usr/lib/x86\_64-linux-gnu/libncurses.so.6 \\  
   /usr/lib/x86\_64-linux-gnu/libncurses.so.5

2. **运行 Hexagon 模拟器**:  
   ``` 
   export DSP\_BUILD\_DIR=hexagon\_Debug\_toolv88\_v79  
   ${HEXAGON\_SDK\_ROOT}/tools/HEXAGON\_Tools/8.8.06/Tools/bin/hexagon-sim \\  
   \-mv79 \\  
   \--simulated\_returnval \\  
   \--usefs ${DSP\_BUILD\_DIR} \\  
   \--pmu\_statsfile ${DSP\_BUILD\_DIR}/pmu\_stats.txt \\  
   \--cosim\_file ${DSP\_BUILD\_DIR}/q6ss.cfg \\  
   \--l2tcm\_base 0xd800 \\  
   \--rtos ${DSP\_BUILD\_DIR}/osam.cfg \\  
   ${HEXAGON\_SDK\_ROOT}/rtos/qurt/computev79/sdksim\_bin/runelf.pbn \\  
   ${HEXAGON\_SDK\_ROOT}/libs/run\_main\_on\_hexagon/ship/hexagon\_toolv88\_v79/run\_main\_o  
   n\_hexagon\_sim \\  
   stack\_size=0x400000 \\  
   libtest\_calculator\_sim.so 64 64 64
   ```
   
   *模拟器运行输出确认了 $M=64$, $K=64$, $N=64$ 的 GEMM 测试成功，并显示了耗时（37ms/36ms）和 PASSED 验证结果*.
   
   ![image-20251103152108131](C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20251103152108131.png)

### **3\. 设备运行 (推荐)**

1. 申请 QDC 设备:  
   在高通 QDC 平台申请骁龙 8 Elite 手机，并选择 SSH 连接方式.  
   
2. **创建私钥并修改权限**:  
   ``` 
   chmod 400 qdc\_id\_2025-10-20\_62.pem

3. **建立设备连接**:  
   * 创建 SSH 隧道 (复制 QDC 页面的连接命令):  
     ```
     ssh \-i qdc\_id\_2025-10-20\_62.pem \-L 5037:sa341225.sa.svc.cluster.local:5037 \-N sshtunnel@ssh.qdc.qualcomm.com

   ![image-20251103152215708](C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20251103152215708.png)
   
   * 验证设备连接:  

     ``` 
     adb devices
     ```
   
     *输出确认设备已连接*.  
   
     ![image-20251103152230673](C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20251103152230673.png)
   
4. 编译 Android 测试工具  
   确保处于 /os-2026/Lab4 目录.  
   ``` 
   export HEXAGON\_SDK\_PATH=/home/qomolangma/Qualcomm/Hexagon\_SDK/6.3.0.0  
   export ANDROID\_NDK\_ROOT=\~/Android/Sdk/ndk/29.0.13113456-beta1/  
   source $HEXAGON\_SDK\_PATH/setup\_sdk\_env.source  
   mkdir build  
   cd build  
   sudo apt install cmake  
   cmake \-DANDROID\_ABI=arm64-v8a \-DANDROID\_PLATFORM=android-24 \\  
         \-DCMAKE\_TOOLCHAIN\_FILE=$ANDROID\_NDK\_ROOT/build/cmake/android.toolchain.cmake \\  
         \-DHEXAGON\_SDK\_ROOT=$HEXAGON\_SDK\_ROOT  
   make
   ```
   
   * make 成功构建了 npu\_gemm\_test.  
   
     ![image-20251103152333308](C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20251103152333308.png)
   
5. 部署并运行测试  
   确保处于 /os-2026/Lab4/build 目录.  
   
   * 推送文件到设备:  
     ``` 
     adb push npu\_gemm\_test /data/local/tmp/  
     adb push ../dsp/hexagon\_Debug\_toolv88\_v79/ship/libcalculator\_skel.so /data/local/tmp/
   
   * 在设备上执行测试:  
     ``` 
     adb shell  
     cd /data/local/tmp  
     chmod \+x npu\_gemm\_test  
     ./npu\_gemm\_test 64 64 64 \--cpu-check
   
   * *设备运行输出确认了 NPU GEMM 计算成功，NPU 和 CPU 结果匹配，耗时 56.217 ms*.
   
   ![image-20251103152414211](C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20251103152414211.png)

## **向量化与对齐分析**

### **HVX 向量宽度**

* HVX 向量长度是 128 字节。  
* 一次可以并行操作 32 个 float。  
* 代码里显式定义了 \#define HVX\_BYTES 128 和 \#define HVX\_F32\_PER\_VEC 32。  
* 所有 HVX 块的循环都是以 32 为步长处理数据。

### **对齐与加载策略**

* 在 HVX 加载时使用了 vloadu\_f32()。  
* vloadu\_f32() 策略是使用 memcpy 搬运 128B 到 HVX\_Vector。  
* 这种策略允许处理连续在内存中的 32 个 float，不强制要求调用点是 128B 对齐的指针，从而避免未对齐 load 指令的限制。  
* 同理，vstoreu\_f32() 使用 memcpy 将计算结果写回内存。  
* 在测试分配矩阵时使用了对齐分配，例如 float A (float\*) memalign (128, ...)。  
* 矩阵起始地址本身是 128B 对齐的，这使大部分主循环访问天然是 aligned，进一步提升性能。

### **尾部处理**

本实验对不满足 32 倍数长度的“尾巴”采用显式标量回退 (scalar fallback)。

* **在外积实现 gemm\_hvx\_outer() 里**:  
  * 主循环只跑到 n\_vec \= (n/32)\*32，即完整的 32 倍数的列块。  
  * 剩下的 j \= n\_vec..n-1 用标量回退。  
* **在内积实现 gemm\_hvx\_dot() 里**:  
  * 主循环只跑到 k\_vec \= (k/32)\*32，即完整的 32 倍数的 K 段。  
  * 剩下的 l \= k\_vec..k-1 用标量回退。

## **性能测量**

在设备上进行了三次实现（Baseline, HVX 内积, HVX 外积）和四种矩阵尺寸的测试。

**最终平均结果 (3 次运行平均)**

| 矩阵尺寸 | baseline 平均耗时 | HVX 内积平均耗时 | HVX 外积平均耗时 |
| :---- | :---- | :---- | :---- |
| 64x64x64 | 47.393 ms | 43.062 ms | 35.388 ms |
| 88x99x66 | 61.347 ms | 47.192 ms | 38.176 ms |
| 256x256x256 | 608.945 ms | 194.569 ms | 130.203 ms |
| 512x512x512 | 6257.481 ms | 997.647 ms | 719.152 ms |

**HVX 相对于 baseline 的平均加速倍数**

| 矩阵尺寸 | HVX 内积加速比 | HVX 外积加速比 |
| :---- | :---- | :---- |
| 64x64x64 | 1.10x | 1.34x |
| 88x99x66 | 1.30x | 1.61x |
| 256x256x256 | 3.13x | 4.68x |
| 512x512x512 | 6.27x | 8.70x |

观察:  
规模越大，加速越夸张。在 512x512x512 尺寸上，HVX 外积平均加速 8.7 倍，接近数量级的提升。

## **瓶颈与优化建议**

1. **小规模开销:** 在 64x64x64 中，HVX 版本只比 baseline 快 1.1\~1.34 倍。这是因为 DSP RPC 调用和初始化开销在小规模下占比较大，向量化准备的固定成本无法充分摊销。  
2. **尾部处理有效:** 对于 $n$ 或 $k$ 不是 32 的倍数（如 $88 \\times 99 \\times 66$），即使有不满 32 的尾部走标量回退，HVX 外积依旧能比 baseline 快 $1.6\\times$ 左右。  
3. **优化建议:** 当前实现未显式使用 l2fetch (L2 预取机制) 或 VTCM (本地 scratchpad) 优化。未来可以尝试：  
   * 在处理下一块数据之前，提前发起 l2fetch 将其调入更快的本地存储。  
   * 将 A 的一行和 B 的一部分 tile 到本地 VTCM，以减少重复从外存加载的次数。  
   * 进一步分块 (tiling) 避免大矩阵直接访问 DDR/L2 带来的带宽瓶颈。  
   * 将 C 的 tile 暂存在 VTCM 中，做多次累加后再回写，以减少总线写流量。