# 实验二：代码纠错

姓名：陈泽超
学号：22551014

### 1. 空指针解引用导致程序崩溃

-   **问题代码**:
    ```c
    freed_ch->next->pprev = &freed_ch->next;
    ```
-   **问题描述**:
    该行代码的目的是更新双向链表中原首节点的 `pprev` 指针，使其指向新插入节点的 `next` 成员地址。但是，当 0 阶空闲链表 `b->free_head[0]` 最初为空时，`freed_ch->next` 会被赋值为 `NULL`。此时，执行 `freed_ch->next->pprev` 相当于对空指针进行解引用，将直接导致段错误（Segmentation Fault），使程序崩溃。

### 2. 错误的指针运算导致循环逻辑失效

-   **问题代码**:
    ```c
    obj = (char *) freed_ct + 1;
    ```
-   **问题描述**:
    该行代码的意图是将 `obj` 指针移动到下一个内存页的起始地址，以便在下一次循环中处理。然而，代码将 `chunk_tail_t*` 类型的 `freed_ct` 指针强制转换为 `char*` 类型，然后加 1。在 C 语言指针运算中，这只会将地址增加 1 个字节，而不是一个 `chunk_tail_t` 结构的大小或一个页的大小。这导致 `obj` 指向了 `chunk_tail_t` 结构内部的某个位置，而不是下一页的开头。这不仅破坏了循环处理多页内存块的逻辑，还会导致后续循环在错误的内存地址上进行操作。